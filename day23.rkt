#lang racket

(define (make-code str)
  (define vals (map string->number
                    (string-split (string-trim str) ",")))
  (for/hash ((i (range (length vals)))
             (v vals))
    (values i v)))

(define get-code
  (let ((code (make-code (file->string "data/input23.txt"))))
    (lambda () (hash-copy code))))

(struct vec2 (x y) #:transparent)

(struct state (pc mem runlevel base address idle output input) #:mutable #:transparent)

(define directions (vector (vec2 0 -1) (vec2 0 1) (vec2 -1 0) (vec2 1 0)))

(define (vec2+ v1 v2)
  (vec2 (+ (vec2-x v1) (vec2-x v2))
        (+ (vec2-y v1) (vec2-y v2))))

(define (run st)
  (define code (state-mem st))
  (define (exec pc input)
    (define bop (hash-ref code pc))
    (define op (remainder bop 100))
    (define (mode n)
      (remainder (quotient bop (expt 10 (+ n 1))) 10))
    (define (get n)
      (let ((val (hash-ref code (+ pc n) 0)))
        (case (mode n)
          ((0) (hash-ref code val 0)) 
          ((1) val)
          ((2) (hash-ref code (+ val (state-base st)) 0)))))
    (define (set n x)
      (define addr (hash-ref code (+ pc n)))
      (case (mode n)
        ((0) (hash-set! code addr x))
        ((1) (error "can't set immediate"))
        ((2) (hash-set! code (+ addr (state-base st)) x))))
    (define (next a)
      (if (and (null? (state-input st)) (null? (state-output st)))
        (set-state-runlevel! st 'idle)
        (set-state-runlevel! st 'work))
      (set-state-pc! st a))
    (define (jump cd)
      (if (cd (= (get 1) 0))
          (next (get 2))
          (next (+ pc 3))))
    (define (test op)
      (set 3 (if (op (get 1) (get 2)) 1 0))
      (next (+ pc 4)))
    (define (do-op f)
      (set 3 (f (get 1) (get 2)))
      (next (+ pc 4)))
    (define (handle-input)
      (if (null? input)
          (begin
            (set 1 -1)
            (set-state-idle! st (+ (state-idle st) 1)))
          (begin
            (set 1 (car input))
            (set-state-idle! st 0)
            (set-state-input! st (cdr input))))
      (next (+ pc 2)))
    (define (handle-output)
      (define op (get 1))
      (set-state-idle! st 0)
      (set-state-output! st (cons op (state-output st)))
      (next (+ pc 2)))
    
    (case op
      ((1) (do-op +))
      ((2) (do-op *))
      ((3) (handle-input))
      ((4) (handle-output))
      ((5) (jump not))
      ((6) (jump (λ (x) x)))
      ((7) (test <))
      ((8) (test =))
      ((9) (set-state-base! st (+ (state-base st) (get 1)))
           (next (+ pc 2)))
      ((99) (set-state-runlevel! 'halted))
      (else (error (format "unknown op ~a" bop)))))
  (exec (state-pc st) (state-input st)))

(define (new-state code n)
  (state 0 code 'ready 0 n 0 '() (list n)))

(define (run-system)
  (define machines (build-vector 50 (λ (x) (new-state (get-code) x))))
  (define nat '())
  (define counter 0)
  (let loop ((n 0))
    (define (handle k)
      (define this (vector-ref machines k))
      (run this)
      (when (= (length (state-output this)) 3)
        (define packet (reverse (state-output this)))
        (set-state-output! this '())
        (let ((addr (car packet)))
          (if (= addr 255)
              (begin
                (set! nat (cdr packet)))
              (let ((that (vector-ref machines addr)))
                (set-state-input! that (append (state-input that) (cdr packet))))))))
    (if (< n (vector-length machines))
        (handle n)
        (loop 0))
    (when (for/and ((st machines))
            (> (state-idle st) 100))
      (set-state-input! (vector-ref machines 0) nat)
      (for ((st machines))
        (set-state-idle! st 0))
      (displayln (format "idle sending ~a" nat)))
    (loop (+ n 1))))
    