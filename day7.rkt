#lang racket

(define (make-code str)
  (list->vector (map string->number
                     (string-split (string-trim str) ","))))

(define get-code
  (let ((code (make-code (file->string "data/input7.txt"))))
    (lambda () (vector-copy code))))

(define (magn n k)
  (= 1 (remainder (quotient n k) 10)))

(struct state (pc code input output runlevel) #:mutable)

(define (run st)
  (define code (state-code st))
  (let exec ((pc (state-pc st)) (input (state-input st)))
    (define bop (vector-ref code pc))
    (define op (remainder bop 100))
    (define (get n)
      (let ((val (vector-ref code (+ pc n))))
        (if (magn bop (expt 10 (+ n 1)))
            val
            (vector-ref code val))))
    (define (set n x)
      (vector-set! code (vector-ref code (+ pc n)) x))
    (define (jump cd)
      (if (cd (= (get 1) 0))
          (exec (get 2) input)
          (exec (+ pc 3) input)))
    (define (test op)
      (set 3 (if (op (get 1) (get 2)) 1 0))
      (exec (+ pc 4) input))
    (define (do-op f)
      (set 3 (f (get 1) (get 2)))
      (exec (+ pc 4) input))
    (define (handle-input)
      (set 1 (car input))
      (exec (+ pc 2) (cdr input)))
    (case op
      ((1) (do-op +))
      ((2) (do-op *))
      ((3) (if (null? input)
               (state pc code input (state-output st) 'waiting)
               (handle-input)))
      ((4) (state (+ pc 2) code input (get 1) 'output))
      ((5) (jump not))
      ((6) (jump (λ (x) x)))
      ((7) (test <))
      ((8) (test =))
      ((99) (state pc code input (state-output st) 'halted))
      (else (error (format "unknown op ~a" bop))))))

(define ((run-loop code) settings)
  (define devs (for/vector ((i settings))
                 (state 0 (code) (list i) #f 'ready)))
  (define (get i)
    (vector-ref devs i))
  (define (set i st)
    (vector-set! devs i st))
  (define (add-input dev i)
    (define st (get dev))
    (set-state-input! st (append (state-input st) (list i)))
    (when (eq? (state-runlevel st) 'waiting)
      (set-state-runlevel! st 'ready)))
  (define (get-ready)
    (filter (λ (i) (eq? (state-runlevel (get i)) 'ready)) '(0 1 2 3 4)))
  (define (exec)
    (let ((ds (get-ready)))
      (if (null? ds)
          (state-output (get 4))
          (begin
            (for ((i ds))
              (let ((nst (run (get i))))
                (when (eq? (state-runlevel nst) 'output)
                  (add-input (remainder (+ i 1) 5) (state-output nst))
                  (set-state-runlevel! nst 'ready))
                (set i nst)))
            (exec)))))
  (add-input 0 0)
  (exec))
  
(define (solve l)
   (foldl (λ (a b) (max b ((run-loop get-code) a))) 0 (permutations l)))

(solve '(0 1 2 3 4))
(solve '(5 6 7 8 9))