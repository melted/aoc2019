#lang racket

(define (make-code str)
  (define vals (map string->number
                    (string-split (string-trim str) ",")))
  (for/hash ((i (range (length vals)))
             (v vals))
    (values i v)))

(define get-code
  (let ((code (make-code (file->string "data/input15.txt"))))
    (lambda () (hash-copy code))))

(struct vec2 (x y) #:transparent)

(struct state (pc mem runlevel base n pos) #:mutable #:transparent)

(define directions (vector (vec2 0 -1) (vec2 0 1) (vec2 -1 0) (vec2 1 0)))

(define (vec2+ v1 v2)
  (vec2 (+ (vec2-x v1) (vec2-x v2))
        (+ (vec2-y v1) (vec2-y v2))))

(define (run st)
  (define code (state-mem st))
  (define (exec pc)
    (define bop (hash-ref code pc))
    (define op (remainder bop 100))
    (define (mode n)
      (remainder (quotient bop (expt 10 (+ n 1))) 10))
    (define (get n)
      (let ((val (hash-ref code (+ pc n) 0)))
        (case (mode n)
          ((0) (hash-ref code val 0)) 
          ((1) val)
          ((2) (hash-ref code (+ val (state-base st)) 0)))))
    (define (set n x)
      (define addr (hash-ref code (+ pc n)))
      (case (mode n)
        ((0) (hash-set! code addr x))
        ((1) (error "can't set immediate"))
        ((2) (hash-set! code (+ addr (state-base st)) x))))
    (define (jump cd)
      (if (cd (= (get 1) 0))
          (exec (get 2))
          (exec (+ pc 3))))
    (define (test op)
      (set 3 (if (op (get 1) (get 2)) 1 0))
      (exec (+ pc 4)))
    (define (do-op f)
      (set 3 (f (get 1) (get 2)))
      (exec (+ pc 4)))
    (define (handle-input)
      (for/list ((i (in-range 1 5)))
        (define new-code (hash-copy code))
        (define (set n x)
          (define addr (hash-ref new-code (+ pc n)))
          (case (mode n)
            ((0) (hash-set! new-code addr x))
            ((1) (error "can't set immediate"))
            ((2) (hash-set! new-code (+ addr (state-base st)) x))))
        (set 1 i)
        (state (+ pc 2)
               new-code
               'input
               (state-base st)
               (+ (state-n st) 1)
               (vec2+ (state-pos st) (vector-ref directions (- i 1))))))
    (define (handle-output)
      (case (get 1)
        ((0) (state pc code 'killed (state-base st) (state-n st) (state-pos st)))
        ((1) (exec (+ pc 2)))
        ((2) (state pc code 'found (state-base st) (state-n st) (state-pos st)))))
    (set-state-pc! st pc)
    (case op
      ((1) (do-op +))
      ((2) (do-op *))
      ((3) (handle-input))
      ((4) (handle-output))
      ((5) (jump not))
      ((6) (jump (Î» (x) x)))
      ((7) (test <))
      ((8) (test =))
      ((9) (set-state-base! st (+ (state-base st) (get 1)))
           (exec (+ pc 2)))
      ((99) (state pc code 'halted (state-base st) (state-n st) (state-pos st)))
      (else (error (format "unknown op ~a" bop)))))
  (exec (state-pc st)))

(define (new-state code)
  (state 0 code 'ready 0 0 (vec2 0 0)))
  
(define (find mapping?)
  (define the-map (mutable-set))
  (define start (new-state (get-code)))
  (define seen (mutable-set))
  (define (winner? states)
    (define (win? state)
      (if (equal? (state-runlevel state) 'found) state #f))
    (ormap win? states))
  (define (continue? state)
    (begin0
      (and (or (equal? (state-runlevel state) 'input) mapping?)
           (not (set-member? seen (state-pos state))))
      (set-add! seen (state-pos state))))
  (let loop ((states (list start)) (n 0))
    (define next-states (flatten (for/list ((s states))
                                   (run s))))
    (when mapping? (for ((s next-states)
                         #:when (equal? (state-runlevel s) 'killed))
                     (set-add! the-map (state-pos s))))
    (cond
      ((null? states) the-map)
      ((and (winner? next-states) (not mapping?)) (winner? next-states))
      (else (loop (filter continue? next-states) (+ n 1))))))

(define (spread start walls)
  (define seen (mutable-set))
  (set-union! seen walls)
  ;; Let's patch the damn thing manually.
  (set-add! seen (vec2 18 -21))
  (set-add! seen (vec2 19 -20))
  (let loop ((next (set start)) (n 0))
    (define (next-states) (for*/set ((s next) (d directions))
                            (vec2+ s d)))
    (for ((p next))
      (set-add! seen p))
    (cond
      ((set-empty? next) (- n 1))
      (else (loop (set-subtract (next-states) seen) (+ n 1))))))

(define st (find #f))
(state-n st)
(define the-map (find #t))
(spread (state-pos st) the-map)

(define (render m)
  (define screen (for/vector ((i (in-range 50)))
                     (make-string 50 #\space)))
  (for ((p m))
    (string-set! (vector-ref screen (+ (vec2-y p) 25)) (+ (vec2-x p) 25) #\#))
  (string-set! (vector-ref screen (+ -20 25)) (+ 18 25) #\O)
  (for ((s screen))
    (displayln s)))